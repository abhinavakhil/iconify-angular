{"ast":null,"code":"/* tslint:disable:no-redundant-jsdoc variable-name no-conditional-assignment no-bitwise */\n/**\n * Unique id counter\n */\nlet idCounter = 0;\n/**\n * Regex used to split dimensions\n */\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\n/**\n * Attributes used for icon\n */\nconst iconAttributes = ['width', 'height', 'inline', 'hFlip', 'vFlip', 'flip', 'rotate', 'align', 'color', 'box'];\n/**\n * Default attribute values\n */\nconst defaultAttributes = {\n  left: 0,\n  top: 0,\n  width: 16,\n  height: 16,\n  rotate: 0,\n  hFlip: false,\n  vFlip: false\n};\n/**\n * Add missing properties to icon\n *\n * Important: in PHP version of this library this function is part of Collection class: Collection::addMissingAttributes()\n *\n * JavaScript version uses separate file so this function could be used in React and other components without loading\n * entire Collection class.\n */\nexport function normalize(data) {\n  const item = Object.assign(Object.create(null), defaultAttributes, data);\n  if (item.inlineTop === void 0) {\n    item.inlineTop = item.top;\n  }\n  if (item.inlineHeight === void 0) {\n    item.inlineHeight = item.height;\n  }\n  if (item.verticalAlign === void 0) {\n    // -0.143 if icon is designed for 14px height,\n    // otherwise assume icon is designed for 16px height\n    item.verticalAlign = item.height % 7 === 0 && item.height % 8 !== 0 ? -0.143 : -0.125;\n  }\n  return item;\n}\n/**\n * Get preserveAspectRatio attribute value\n */\nexport function getAlignment(align) {\n  let result;\n  switch (align.horizontal) {\n    case 'left':\n      result = 'xMin';\n      break;\n    case 'right':\n      result = 'xMax';\n      break;\n    default:\n      result = 'xMid';\n  }\n  switch (align.vertical) {\n    case 'top':\n      result += 'YMin';\n      break;\n    case 'bottom':\n      result += 'YMax';\n      break;\n    default:\n      result += 'YMid';\n  }\n  result += align.slice ? ' slice' : ' meet';\n  return result;\n}\n/**\n * SVG class\n *\n * @see @iconify/json-tools/src/svg.js\n */\nexport class SVG {\n  /**\n   * Constructor\n   *\n   *  Use Collection.getIconData() to retrieve icon data\n   */\n  constructor(_icon) {\n    this._icon = _icon;\n  }\n  /**\n   * Calculate second dimension when only 1 dimension is set\n   * If size == width, ratio = height/width\n   * If size == height, ratio = width/height\n   */\n  static calculateDimension(size, ratio, precision = 100) {\n    if (ratio === 1) {\n      return size;\n    }\n    if (typeof size === 'number') {\n      return Math.ceil(size * ratio * precision) / precision;\n    }\n    // split code into sets of strings and numbers\n    const split = size.split(unitsSplit);\n    if (split === null || !split.length) {\n      return null;\n    }\n    const results = [];\n    let code = split.shift();\n    let isNumber = unitsTest.test(code);\n    let num;\n    while (true) {\n      if (isNumber) {\n        num = parseFloat(code);\n        if (isNaN(num)) {\n          results.push(code);\n        } else {\n          results.push(Math.ceil(num * ratio * precision) / precision);\n        }\n      } else {\n        results.push(code);\n      }\n      // next\n      code = split.shift();\n      if (code === void 0) {\n        return results.join('');\n      }\n      isNumber = !isNumber;\n    }\n  }\n  /**\n   * Replace IDs in SVG output with unique IDs\n   * Fast replacement without parsing XML, assuming commonly used patterns.\n   */\n  static replaceIDs(body) {\n    const regex = /\\sid=\"(\\S+)\"/g;\n    const ids = [];\n    let match;\n    let prefix;\n    function strReplace(search, replace, subject) {\n      let pos = 0;\n      while ((pos = subject.indexOf(search, pos)) !== -1) {\n        subject = subject.slice(0, pos) + replace + subject.slice(pos + search.length);\n        pos += replace.length;\n      }\n      return subject;\n    }\n    // Find all IDs\n    while (match = regex.exec(body)) {\n      ids.push(match[1]);\n    }\n    if (!ids.length) {\n      return body;\n    }\n    prefix = 'IconifyId-' + Date.now().toString(16) + '-' + (Math.random() * 0x1000000 | 0).toString(16) + '-';\n    // Replace with unique ids\n    ids.forEach(id => {\n      const newID = prefix + idCounter;\n      idCounter++;\n      body = strReplace('=\"' + id + '\"', '=\"' + newID + '\"', body);\n      body = strReplace('=\"#' + id + '\"', '=\"#' + newID + '\"', body);\n      body = strReplace('(#' + id + ')', '(#' + newID + ')', body);\n    });\n    return body;\n  }\n  /**\n   * Get SVG attributes\n   */\n  getAttributes(props) {\n    const item = this._icon;\n    if (typeof props !== 'object') {\n      props = Object.create(null);\n    }\n    // Set data\n    const align = {\n      horizontal: 'center',\n      vertical: 'middle',\n      slice: false\n    };\n    const transform = {\n      rotate: item.rotate,\n      hFlip: item.hFlip,\n      vFlip: item.vFlip\n    };\n    const style = Object.create(null);\n    const attributes = Object.create(null);\n    // Get width/height\n    const inline = props.inline === true || props.inline === 'true' || props.inline === '1';\n    const box = {\n      left: item.left,\n      top: inline ? item.inlineTop : item.top,\n      width: item.width,\n      height: inline ? item.inlineHeight : item.height\n    };\n    // Transformations\n    ['hFlip', 'vFlip'].forEach(key => {\n      if (props[key] !== void 0 && (props[key] === true || props[key] === 'true' || props[key] === '1')) {\n        transform[key] = !transform[key];\n      }\n    });\n    if (props.flip !== void 0) {\n      props.flip.toLowerCase().split(/[\\s,]+/).forEach(value => {\n        switch (value) {\n          case 'horizontal':\n            transform.hFlip = !transform.hFlip;\n            break;\n          case 'vertical':\n            transform.vFlip = !transform.vFlip;\n        }\n      });\n    }\n    if (props.rotate !== void 0) {\n      let value = props.rotate;\n      if (typeof value === 'number') {\n        transform.rotate += value;\n      } else if (typeof value === 'string') {\n        const units = value.replace(/^-?[0-9.]*/, '');\n        if (units === '') {\n          value = parseInt(value, 10);\n          if (!isNaN(value)) {\n            transform.rotate += value;\n          }\n        } else if (units !== value) {\n          let split = false;\n          switch (units) {\n            case '%':\n              // 25% -> 1, 50% -> 2, ...\n              split = 25;\n              break;\n            case 'deg':\n              // 90deg -> 1, 180deg -> 2, ...\n              split = 90;\n          }\n          if (split) {\n            value = parseInt(value.slice(0, value.length - units.length), 10);\n            if (!isNaN(value)) {\n              transform.rotate += Math.round(value / split);\n            }\n          }\n        }\n      }\n    }\n    // Apply transformations to box\n    const transformations = [];\n    let tempValue;\n    if (transform.hFlip) {\n      if (transform.vFlip) {\n        transform.rotate += 2;\n      } else {\n        // Horizontal flip\n        transformations.push('translate(' + (box.width + box.left) + ' ' + (0 - box.top) + ')');\n        transformations.push('scale(-1 1)');\n        box.top = box.left = 0;\n      }\n    } else if (transform.vFlip) {\n      // Vertical flip\n      transformations.push('translate(' + (0 - box.left) + ' ' + (box.height + box.top) + ')');\n      transformations.push('scale(1 -1)');\n      box.top = box.left = 0;\n    }\n    switch (transform.rotate % 4) {\n      case 1:\n        // 90deg\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift('rotate(90 ' + tempValue + ' ' + tempValue + ')');\n        // swap width/height and x/y\n        if (box.left !== 0 || box.top !== 0) {\n          tempValue = box.left;\n          box.left = box.top;\n          box.top = tempValue;\n        }\n        if (box.width !== box.height) {\n          tempValue = box.width;\n          box.width = box.height;\n          box.height = tempValue;\n        }\n        break;\n      case 2:\n        // 180deg\n        transformations.unshift('rotate(180 ' + (box.width / 2 + box.left) + ' ' + (box.height / 2 + box.top) + ')');\n        break;\n      case 3:\n        // 270deg\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift('rotate(-90 ' + tempValue + ' ' + tempValue + ')');\n        // swap width/height and x/y\n        if (box.left !== 0 || box.top !== 0) {\n          tempValue = box.left;\n          box.left = box.top;\n          box.top = tempValue;\n        }\n        if (box.width !== box.height) {\n          tempValue = box.width;\n          box.width = box.height;\n          box.height = tempValue;\n        }\n        break;\n    }\n    // Calculate dimensions\n    // Values for width/height: null = default, 'auto' = from svg, false = do not set\n    // Default: if both values aren't set, height defaults to '1em', width is calculated from height\n    const customWidth = props.width ? props.width : null;\n    let customHeight = props.height ? props.height : null;\n    let width;\n    let height;\n    if (customWidth === null && customHeight === null) {\n      customHeight = '1em';\n    }\n    if (customWidth !== null && customHeight !== null) {\n      width = customWidth;\n      height = customHeight;\n    } else if (customWidth !== null) {\n      width = customWidth;\n      height = SVG.calculateDimension(width, box.height / box.width);\n    } else {\n      height = customHeight;\n      width = SVG.calculateDimension(height, box.width / box.height);\n    }\n    if (width !== false) {\n      attributes.width = width === 'auto' ? box.width : width;\n    }\n    if (height !== false) {\n      attributes.height = height === 'auto' ? box.height : height;\n    }\n    // Add vertical-align for inline icon\n    if (inline && item.verticalAlign !== 0) {\n      style['vertical-align'] = item.verticalAlign + 'em';\n    }\n    // Check custom alignment\n    if (props.align !== void 0) {\n      props.align.toLowerCase().split(/[\\s,]+/).forEach(value => {\n        switch (value) {\n          case 'left':\n          case 'right':\n          case 'center':\n            align.horizontal = value;\n            break;\n          case 'top':\n          case 'bottom':\n          case 'middle':\n            align.vertical = value;\n            break;\n          case 'crop':\n            align.slice = true;\n            break;\n          case 'meet':\n            align.slice = false;\n        }\n      });\n    }\n    // Generate viewBox and preserveAspectRatio attributes\n    attributes.preserveAspectRatio = getAlignment(align);\n    attributes.viewBox = box.left + ' ' + box.top + ' ' + box.width + ' ' + box.height;\n    // Generate body\n    let body = SVG.replaceIDs(item.body);\n    if (props.color !== void 0) {\n      body = body.replace(/currentColor/g, props.color);\n    }\n    if (transformations.length) {\n      body = '<g transform=\"' + transformations.join(' ') + '\">' + body + '</g>';\n    }\n    if (props.box === true || props.box === 'true' || props.box === '1') {\n      // Add transparent bounding box\n      // tslint:disable-next-line:max-line-length\n      body += '<rect x=\"' + box.left + '\" y=\"' + box.top + '\" width=\"' + box.width + '\" height=\"' + box.height + '\" fill=\"rgba(0, 0, 0, 0)\" />';\n    }\n    return {\n      attributes,\n      body,\n      style\n    };\n  }\n  /**\n   * Generate SVG\n   */\n  getSVG(attributes) {\n    const data = this.getAttributes(attributes);\n    let svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    // Add SVG attributes\n    Object.keys(data.attributes).forEach(attr => {\n      svg += ' ' + attr + '=\"' + data.attributes[attr] + '\"';\n    });\n    // Add style with 360deg transformation to style to prevent subpixel rendering bug\n    svg += ' style=\"-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);';\n    Object.keys(data.style).forEach(attr => {\n      svg += ' ' + attr + ': ' + data.style[attr] + ';';\n    });\n    svg += '\">';\n    svg += data.body + '</svg>';\n    return svg;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}